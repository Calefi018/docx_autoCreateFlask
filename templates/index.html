import os
import io
import json
import re
from flask import Flask, render_template, request, send_file, jsonify
from docx import Document
import google.generativeai as genai

app = Flask(__name__)

CHAVE_API = os.environ.get("GEMINI_API_KEY")
if CHAVE_API:
    genai.configure(api_key=CHAVE_API)

# =========================================================
# FUNÇÕES DA FERRAMENTA 1: PREENCHEDOR CLÁSSICO (COM TAGS)
# =========================================================
def preencher_template_com_tags(arquivo_template, dicionario_dados):
    doc = Document(arquivo_template)

    def processar_paragrafo(paragrafo):
        texto_original = paragrafo.text
        tem_tag = False
        
        for marcador, texto_novo in dicionario_dados.items():
            if marcador in texto_original:
                # Troca a tag segura [QUEBRA] pela quebra de linha real do Word
                texto_formatado = str(texto_novo).replace("[QUEBRA]", "\n")
                texto_original = texto_original.replace(marcador, texto_formatado)
                tem_tag = True
                
        if tem_tag:
            paragrafo.clear()
            # TRADUTOR DE MARKDOWN PARA WORD
            linhas = texto_original.split('\n')
            for i, linha in enumerate(linhas):
                partes = linha.split('**')
                for j, parte in enumerate(partes):
                    if parte: 
                        run = paragrafo.add_run(parte)
                        if j % 2 == 1: 
                            run.bold = True
                if i < len(linhas) - 1:
                    paragrafo.add_run('\n')

    # Varre corpo do texto
    for paragrafo in doc.paragraphs:
        processar_paragrafo(paragrafo)

    # Varre tabelas e caixas de texto
    for tabela in doc.tables:
        for linha in tabela.rows:
            for celula in linha.cells:
                for paragrafo in celula.paragraphs:
                    processar_paragrafo(paragrafo)

    arquivo_saida = io.BytesIO()
    doc.save(arquivo_saida)
    arquivo_saida.seek(0)
    return arquivo_saida

def gerar_respostas_ia_tags(texto_tema, nome_modelo):
    modelo = genai.GenerativeModel(nome_modelo)
    prompt = f"""
    Você é um Especialista Acadêmico Sênior com Doutorado em Gestão. Sua missão é resolver um Desafio Profissional Universitário.
    
    REGRA DE OURO (QUALIDADE EXTREMA): 
    É EXPRESSAMENTE PROIBIDO ser raso ou breve. Suas respostas devem ser DENSAS, PROFUNDAS e usar vocabulário técnico acadêmico rigoroso. Cada justificativa e análise deve ter múltiplas linhas de argumentação fundamentada.
    
    REGRA DE FORMATAÇÃO DO JSON:
    1. Retorne APENAS o JSON válido. NENHUM texto fora das chaves.
    2. NUNCA use "Enter" (quebra de linha real) dentro das strings. Se precisar pular linha ou fazer tópicos, digite a palavra exata [QUEBRA].
    3. Use **negrito** para destacar conceitos chave. NUNCA use asteriscos simples (*).
    
    TEMA/CASO DO DESAFIO:
    {texto_tema}
    
    RETORNE EXATAMENTE ESTE JSON PREENCHIDO COM TEXTOS LONGOS E COMPLEXOS:
    {{
        "ASPECTO_1": "Descreva o aspecto 1 de forma técnica e profunda",
        "POR_QUE_1": "Justifique o aspecto 1 com uma análise densa de pelo menos 4 linhas...",
        "ASPECTO_2": "Descreva o aspecto 2 de forma técnica",
        "POR_QUE_2": "Justifique o aspecto 2 com uma análise densa de pelo menos 4 linhas...",
        "ASPECTO_3": "Descreva o aspecto 3 de forma técnica",
        "POR_QUE_3": "Justifique o aspecto 3 com uma análise densa de pelo menos 4 linhas...",
        "CONCEITOS_TEORICOS": "- **[Nome do Conceito 1]:** [Explicação teórica longa e detalhada sobre como se aplica ao caso][QUEBRA]- **[Nome do Conceito 2]:** [Explicação teórica longa...]",
        "RESP_AUTORRESP": "Análise teórica profunda de no mínimo um parágrafo longo...",
        "RESP_PILARES": "Análise teórica densa, conectando a teoria aos sintomas descritos no caso...",
        "RESP_SOLUCOES": "Plano de ação robusto listando etapas complexas e justificadas...",
        "RESUMO_MEMORIAL": "Resumo executivo denso e bem estruturado...",
        "CONTEXTO_MEMORIAL": "Contextualização rica detalhando as nuances do problema...",
        "ANALISE_MEMORIAL": "Análise profunda com múltiplos parágrafos, interligando no mínimo 3 conceitos da disciplina...",
        "PROPOSTAS_MEMORIAL": "Recomendações técnicas detalhadas e justificadas por teorias...",
        "CONCLUSAO_MEMORIAL": "Conclusão madura sobre o aprendizado sistêmico do caso...",
        "AUTOAVALIACAO_MEMORIAL": "Autoavaliação crítica do aluno, evidenciando amadurecimento acadêmico..."
    }}
    """
    try:
        resposta = modelo.generate_content(prompt)
        texto_limpo = resposta.text.strip()
        
        # Extrator Blindado de JSON (Evita o erro 500)
        match = re.search(r'\{.*\}', texto_limpo, re.DOTALL)
        if match:
            texto_limpo = match.group(0)
            
        dicionario_dados = json.loads(texto_limpo)
        
        dicionario_higienizado = {}
        for chave, texto_gerado in dicionario_dados.items():
            if isinstance(texto_gerado, str):
                texto_gerado = texto_gerado.replace("{", "").replace("}", "").replace("[", "").replace("]", "").replace("*", "").strip()
                texto_gerado = texto_gerado.replace("QUEBRA", "[QUEBRA]")
            else:
                texto_gerado = str(texto_gerado)
                
            chave_limpa = chave.replace("{", "").replace("}", "").strip()
            chave_marcador = f"{{{{{chave_limpa}}}}}"
            dicionario_higienizado[chave_marcador] = texto_gerado
            
        return dicionario_higienizado
    except Exception as e:
        raise Exception(f"Falha na formatação da IA. Clique em gerar novamente. Detalhe: {str(e)}")

# =========================================================
# FUNÇÕES DA FERRAMENTA 2: GERADOR UNIVERSAL (GABARITO)
# =========================================================
def extrair_texto_docx(arquivo_upload):
    doc = Document(arquivo_upload)
    texto_completo = [p.text for p in doc.paragraphs if p.text.strip()]
    return "\n".join(texto_completo)

def gerar_resolucao_inteligente_gabarito(texto_template, texto_tema, nome_modelo):
    modelo = genai.GenerativeModel(nome_modelo)
    prompt = f"""
    Atue como um Especialista Acadêmico Sênior resolvendo um Desafio Profissional.
    TEMA/CASO: {texto_tema}
    TEMPLATE: {texto_template}
    
    REGRA MÁXIMA DE COMPORTAMENTO E QUALIDADE:
    - NÃO use NENHUMA saudação ou despedida. Vá DIRETO AO PONTO.
    - É EXPRESSAMENTE PROIBIDO gerar conteúdo raso. Exijo parágrafos densos, análises profundas e vocabulário acadêmico de alto nível.
    
    ESTRUTURA VISUAL OBRIGATÓRIA (SIGA EXATAMENTE ESTE PADRÃO MARKDOWN):
    
    Pré-visualização do Resultado:
    Olá! Serei seu especialista acadêmico neste Desafio Profissional. Vamos preencher o template passo a passo.
    
    ---
    **Na Etapa 1 (Apresentação do Desafio Profissional), você deve apenas ler e compreender o desafio.**
    
    ---
    **Na Etapa 2 (Materiais de referência - ambientação), escreva isso:**
    
    **1. O que chamou atenção:** **[Escreva o Conceito do Aspecto 1]**
    - **Por quê:** [Justificativa técnica e profunda de no mínimo 4 linhas]
    
    **2. O que chamou atenção:** **[Escreva o Conceito do Aspecto 2]**
    - **Por quê:** [Justificativa técnica e profunda de no mínimo 4 linhas]
    
    **3. O que chamou atenção:** **[Escreva o Conceito do Aspecto 3]**
    - **Por quê:** [Justificativa técnica e profunda de no mínimo 4 linhas]
    
    ---
    **Na Etapa 3 (Levantamento de conceitos teóricos), escreva isso:**
    
    - **[Nome do Conceito 1]:** [Definição extensa e elaborada mostrando como se aplica ao caso]
    - **[Nome do Conceito 2]:** [Definição extensa e elaborada...]
    - **[Nome do Conceito 3]:** [Definição extensa e elaborada...]
    - **[Nome do Conceito 4]:** [Definição extensa e elaborada...]
    
    ---
    **Na Etapa 4 (Aplicação dos conceitos teóricos ao Desafio Profissional), escreva isso:**
    
    - **Como o conceito de [Conceito Principal] explica o que aconteceu na situação?**
      [Parágrafo analítico longo e detalhado dissecando o problema]
    - **O que a teoria nos ajuda a entender sobre o problema central?**
      [Parágrafo profundo conectando sintomas e teorias]
    - **Que soluções possíveis a teoria aponta (e por que elas fazem sentido)?**
      [Propostas práticas detalhadas fundamentadas na teoria]
      
    ---
    **Na Etapa 5 (Memorial Analítico), escreva isso:**
    
    **Resumo do que você descobriu:** [Parágrafo denso]
    **Contextualização do desafio:** [Quem? Onde? Qual a situação? Parágrafo denso]
    **Análise:** [Parágrafo profundo de pelo menos 6 linhas utilizando conceitos para explicar a situação]
    **Propostas de solução:** [Recomendações detalhadas. Pelo menos 2 parágrafos robustos]
    **Conclusão reflexiva:** [O que aprendeu de forma madura. Pelo menos 2 parágrafos]
    **Referências:** [Liste no padrão ABNT]
    **Autoavaliação:** [Análise crítica sobre o próprio processo de estudo]
    """
    try:
        resposta = modelo.generate_content(prompt)
        return resposta.text
    except Exception as e:
        raise Exception(f"Falha na IA (Gabarito): {str(e)}")

# =========================================================
# ROTAS WEB
# =========================================================
@app.route('/')
def index():
    modelos_disponiveis = []
    if CHAVE_API:
        try:
            for m in genai.list_models():
                if 'generateContent' in m.supported_generation_methods:
                    modelos_disponiveis.append(m.name.replace('models/', ''))
        except:
            pass
            
    # Força o Flash rápido e robusto a ser a primeira opção (para não bater o limite)
    if "gemini-1.5-flash" not in modelos_disponiveis:
        modelos_disponiveis.insert(0, "gemini-1.5-flash")
        
    if not modelos_disponiveis:
        modelos_disponiveis = ["gemini-1.5-flash", "gemini-2.5-flash"]
        
    return render_template('index.html', modelos=modelos_disponiveis)

@app.route('/processar', methods=['POST'])
def processar():
    try:
        if not CHAVE_API:
            genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))
            
        ferramenta = request.form.get('ferramenta')
        modelo_escolhido = request.form.get('modelo')
        texto_tema = request.form.get('tema')
        arquivo_upload = request.files['arquivo']
        
        if not arquivo_upload or not texto_tema:
            return jsonify({"erro": "Arquivo Word ou tema do desafio não foram enviados."}), 400

        arquivo_memoria = io.BytesIO(arquivo_upload.read())

        if ferramenta == 'preenchedor':
            respostas_geradas = gerar_respostas_ia_tags(texto_tema, modelo_escolhido)
            if respostas_geradas:
                documento_pronto = preencher_template_com_tags(arquivo_memoria, respostas_geradas)
                return send_file(
                    documento_pronto, 
                    as_attachment=True, 
                    download_name="Desafio_Preenchido_Academico.docx",
                    mimetype="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                )
        
        elif ferramenta == 'gabarito':
            texto_do_template = extrair_texto_docx(arquivo_memoria)
            resposta_ia = gerar_resolucao_inteligente_gabarito(texto_do_template, texto_tema, modelo_escolhido)
            if resposta_ia:
                return jsonify({"tipo": "texto", "conteudo": resposta_ia})
                
        return jsonify({"erro": "Opção inválida selecionada."}), 400
        
    except Exception as e:
        return jsonify({"erro": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
